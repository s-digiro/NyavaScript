((lambda ()
    (let // env
        ((foo
            (let ((x NIL))
                (lambda (y) (set x y)))))
        (foo foo))))

             .-> foo <.
main <- env -'    |   |
         ^        |   |
         '- xenv <'   |
              '-------'
env         clones: xenv.env
env.foo     clones: xenv.foo
xenv.foo    clones:
xenv.env    clones:
foo.xenv    clones:

env gets dropped
    *env.drop()
        *env still has reference xenv.env
        *env is decremented from 2 to 1
    env tries to drop clones
        call xenv.env.tryDrop()
            has no parent
            keep it

((lambda ()
    (let // env
        ((foo
            (let ((x NIL))
                (lambda (y) (
                    (set x y)
                    (defun z foo))))))
        (foo foo))))

foo becomes lambda with xenv
foo foo sets foo's xenv to foo
foo contains ref to xenv xenv contains ref to foo
refs:
    foo -> xenv
    xenv -> foo
    NIL -> foo
foo -> xenv
 ^      |
 '------'

when foo goes out of main scope, foo should be dropped
    xenv ref prevents it from being dropped
        if xenv->foo were weak, this wouldn't be a problem
        alternatively, we can make foo set its xenv to None?

xenv should only be dropped when both MAIN and foo drop it
    xenv needs to be in strong rc for both refs

when foo leaves main scope, foo sets its xenv to NOne?
    How to detect when it leaves main scope?

Special mark for delete RC
call RC.mark for delete
drop rc

diff rcs to same place need to be identifiably different

refs:
    foo -> xenv (xenv parent is foo RcWithParent)
    xenv -> foo (foo parent is xenv RcWithParent)
    NIL -> foo (foo parent is MAIN)

TREE DETECTION STRAT
~~~~~~~~~~~~~~~~~~
RcWithParent {
    parent: Option<WeakRcWithParent>,
    clones: list of weakrcswithparent cloned from this one
    p: Rust Rc
}

let RC = RcWithParent
    RC::new(asdasd, Some(RC<parent>))
    RC::clone(asdfadf, parent)
    RC::drop()
        self.p.drop();
        // inner rc will decrement or go away completely
        call try drop on clones
    RC::tryDrop()
        if has parent
            let x = set of rcs
            if parent leads back to self, or cycle
                self.drop()
            if parent leads to invalid weak
                self.drop()
            if parent leads back to None/Root parent
                keep it
            (It's going to either lead to self, cycle, or None/Root)
        else
            keep it

This will work, but always make sure to set RcWithParent's parent to the Rc
that will be holding it

WRONG
~~~~~
I think the only rcs that actually need a parent set are rcs holding envs
and rcs cloned and stored in an already existing scope

Everything needs it


BLACKLIST STRAT
Not viable, only works for loops with 2 nodes
