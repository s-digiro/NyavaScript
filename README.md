# To Do
- [ ] We need special escape chars
    - [ ] \n should lex into newline
    - [ ] More. Make a list
- [ ] c library dynamic loading
    - [x] Library object which is basically just a wrapper around lib pointer
        - [x] implement (Called DynCLib)
        - [x] test
            - [x] dlopen
            - [x] invalid dlsym
            - [x] STT_GNU_IFUNC
                - [x] can get
                - [x] get ifunc
                - [x] can call
            - [x] STT_OBJECT
                - [x] can get
                - [x] get object
                - [x] Can get values
            - [x] STT_FUNC
                - [x] can get
                - [x] get func
                - [x] Func can be called
    - [x] dynlib scope
        - [x] Put it in its own stack
        - [x] implement
        - [x] test
    - [x] dynlib Function
        - [x] Hold Rc to library it is from
        - [x] Convert sxrefs to whatever they should be converted to
        - [x] implement
        - [x] test
    - [ ] dynlib Object ptr
        - [ ] test
            - [ ] Make sure deref does what we want
            - [ ] make sure we can write to it
    - [x] function like "cload" or something which loads dynamic libs
        - [x] implement
        - [x] test
    - [x] function deref which gets val at mem address
        - [x] implement
        - [x] test
    - [ ] function setat which sets val at mem address
        - [ ] implement
        - [ ] test
- [ ] Figure out some way to implement maps
- [ ] Sys calls somehow
- [ ] Rename s\_expression to form
- [ ] Rename function to procedure
    - [ ] Make sure this reflects in toString as well
- [ ] PartialEq on procedures
    - [ ] Rust: When function is created, create it as a singleton with a timestamp hash
        - [ ] Compare Hashes
    - [ ] Lisp: Same as with Rust
- [ ] Float type
- [ ] Buffer type
    - [ ] This would also mean arrays and objects and structs, effectively
- [ ] load for loading in other files
- [ ] A compiler (lol)
- [ ] Control flow scope
    - [ ] while loop
    - [ ] let macro
    - [ ] define global var
- [ ] String scope
    - [ ] print
    - [ ] println
    - [ ] string concatenation
    - [ ] string indexing
    - [ ] string length
    - [ ] string to list of chars
- [ ] Math scope
    - [ ] Math operations
        - [ ] Addition
        - [ ] Subtraction
        - [ ] Multiplication
        - [ ] Division
        - [ ] Modulo
    - [ ] bitwise operations
        - [ ] and
        - [ ] or
        - [ ] left shift
        - [ ] right shift
        - [ ] not
- [ ] Consider returning data type errors rather than evaluating errors to nil
- [ ] Pass env to macro
- [ ] Add line and column to errors where applicable
- [ ] Passing lambdas to other lambdas is a lil weird... figure it out
- [ ] Lib user defined Rust Contexts
- [ ] Figure out the difference and standard practices between e2e tests and lib unit tests
- [ ] Garbage collector
- [ ] Evaluate List should be refactored into more functions so its easier to read
- [ ] List macro
- [ ] Label macro
- [ ] let macro
- [ ] arbitrary cdaddr function
- [ ] From SX for SXRef
- [ ] From inner for SXRef
- [ ] From inner for SX
- [ ] Better toString for Function
- [ ] Better toString for Macro
- [ ] Find a way to implement PartialEq on RustFunction
- [ ] Find a way to implement PartialEq on RustMacro

# Potential features
- [ ] inline assembly????
- [ ] Fraction type?
- [ ] Array literal?
- [ ] Maybe root lists should execute concurrently?
- [ ] Concurrent macro?
- [ ] set? Maybe?
- [ ] Maybe strings should be lists of chars? Or maybe permanently quoted symbols? Pick one
- [ ] Maybe mccarthy functions should be "specials", separate from macros? decide.
- [ ] Blob data type
- [ ] Fixed array data type
- [ ] Vector data type
- [ ] HashMap data type
- [ ] Set data type
